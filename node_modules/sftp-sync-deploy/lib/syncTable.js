"use strict";
const minimatch = require("minimatch");
const path = require("path");
class SyncTableEntry {
    constructor(table, name) {
        this.table = table;
        this.name = name;
        this.localStat = null;
        this.remoteStat = null;
        this.path = path.posix.join(table.relativePath || '.', name);
    }
    /**
     * Get a task for this entry
     */
    getTask() {
        if (this.task) {
            return this.task;
        }
        let task = { method: undefined, removeRemote: false, hasError: false };
        if (this.localStat === 'error' || this.remoteStat === 'error') {
            task.hasError = true;
        }
        if (this.remoteStat !== null && !task.hasError &&
            (!this.localStat || this.localStat === 'ignore' || this.localStat !== this.remoteStat)) {
            task.removeRemote = true;
        }
        if (this.localStat === 'ignore' || task.hasError) {
            task.method = 'noop';
        }
        else if (this.localStat === 'file') {
            task.method = 'upload';
        }
        else if (this.localStat === 'dir') {
            task.method = 'sync';
        }
        else {
            task.method = 'noop';
        }
        return this.task = task;
    }
    /**
     * Output live run mode log
     */
    liveRunLog() {
        let task = this.getTask();
        let displayName = this.path;
        if (task.removeRemote) {
            if (this.remoteStat === 'dir') {
                console.log(' remote dir removed : '.red + displayName);
            }
            else {
                console.log('remote file removed : '.red + displayName);
            }
        }
        else if (task.hasError) {
            console.log(`              error : ${displayName}`.bgRed);
        }
        else if (task.method === 'noop') {
            console.log('            ignored : '.gray + displayName);
        }
        if (task.method === 'sync') {
            console.log('     sync completed : '.cyan + displayName);
        }
        else if (task.method === 'upload') {
            console.log('      file uploaded : '.yellow + displayName);
        }
    }
    /**
     * Output dry run mode log
     */
    dryRunLog() {
        let taskName = '';
        let task = this.getTask();
        function label(stat) {
            switch (stat) {
                case 'dir': return 'D'.cyan;
                case 'file': return 'F'.yellow;
                case 'ignore': return 'X'.gray;
                case 'error': return '!'.red;
                default: return ' ';
            }
        }
        if (this.remoteStat === 'error') {
            taskName = 'denied';
        }
        else if (task.removeRemote) {
            taskName = 'remove remote';
            if (task.method !== 'noop') {
                taskName += ' and ' + task.method;
            }
        }
        else if (task.method === 'noop') {
            taskName = 'ignore';
        }
        else {
            taskName = task.method;
        }
        console.log(`[ ${label(this.localStat)} | ${label(this.remoteStat)} ] ${this.path}`);
        console.log(`          -> ${taskName}`.magenta);
        console.log('');
    }
    /**
     * Check if the path matches the exclude patterns
     */
    detectExclusion(patterns) {
        let pathForMatch = this.path;
        if (this.localStat === 'dir') {
            pathForMatch += path.posix.sep;
        }
        if (patterns.some(pattern => minimatch(pathForMatch, pattern))) {
            this.localStat = 'ignore';
        }
    }
}
exports.SyncTableEntry = SyncTableEntry;
class SyncTable {
    constructor(relativePath) {
        this.relativePath = relativePath;
        this.registry = [];
    }
    get(filename) {
        return this.registry.find(e => e.name === filename);
    }
    get all() {
        return this.registry;
    }
    set(filename, stats) {
        let entry = this.get(filename);
        let isNew = false;
        if (!entry) {
            entry = new SyncTableEntry(this, filename);
            isNew = true;
        }
        Object.assign(entry, stats);
        if (isNew) {
            this.registry.push(entry);
        }
        return entry;
    }
    has(filename) {
        return this.registry.some(e => e.name === filename);
    }
    forEach(fn) {
        for (let name in this.registry) {
            fn(this.registry[name], name);
        }
    }
}
exports.SyncTable = SyncTable;
